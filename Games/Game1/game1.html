<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Survival</title>
    <link rel="shortcut icon" type="image/PNG" href="../../favicon.PNG">
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style type="text/css">
        body,html {
            margin: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;    
            background-color: black;
            background-image: url('../../Images/background3.jpeg');
            background-size: 50vh;
            background-repeat: repeat;
        }

    </style>
</head>
<body>
<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    width: 1280,
    height: 720,
    scale : {
        mode: Phaser.Scale.FIT,
        // autoCenter: Phaser.Scale.CENTER_BOTH,//for when i implement fs
    },
    physics: {
        default: 'arcade',
        arcade: {
            // gravity: {y: 200},
            debug: false,
        },
    }, 
    fps: {
        target: 60,
        forceSetTimeOut: true,
    },
    pixelArt: true,
    scene: {
        preload: preload,
        create: create,
        update: update
    }

};

var game = new Phaser.Game(config);


//player
var player;
var playerBullets;
var playerLives = 3;
var playerDead = false;
var fireTime = MAXFIRERATE = 8;
//explosions
var explosions;
//stars
var stars;
var starColors = ['ebc634','34d3eb','eb34d9','34eb46', 'ffffff', 'ffffff', 'ffffff']
//side rocks
var sideRocks;
//enemies
var enemies1;
//input keys
var keyW, keyA, keyS, keyD, keySpace, keyEnter;
//text
var FPS, scoreText, roundText, middleScreenText;
//score et. al.
var score = 0, round = 1;
var enemies1Spawned = 0, enemies1Left = 0, maxE1 = 3, e1Killed = 0;
var enemies2Spawned = 0, enemies2Left = 0, maxE2 = undefined, e2Killed = 0;
var enemies3Spawned = 0, enemies3Left = 0, maxE3 = undefined, e3Killed = 0;
//sounds
var fire, burst;
//other flags
var loaded = false, gameStarted = false, nextRoundCalled = false, countDown = 3;
var flashInt, countDownInt;//intervals


function preload(){
    //images
    this.load.image('star','assets/star.png');
    this.load.image('sideRock','assets/clouds.png');
    this.load.image('pBullet','assets/pBullet.png');
    
    //spritesheets
    this.load.spritesheet('shipNT','assets/shipST.png', {frameWidth: 16, frameHeight: 14});
    this.load.spritesheet('shipST','assets/shipST.png', {frameWidth: 16, frameHeight: 21});
    this.load.spritesheet('shipBT','assets/shipBT.png', {frameWidth: 16, frameHeight: 22});
    this.load.spritesheet('enemies1','assets/enemy1.png', {frameWidth: 16, frameHeight: 13});
    this.load.spritesheet('explosion','assets/playerExplosion.png', {frameWidth: 16, frameHeight: 16});

    //audio
    this.load.audio('fire','assets/LaserFire1.wav');
    loadFont();
}


function create(){
    this.physics.world.setBounds(140,0,1000,720);

    //space (aka moving stars)
    stars = this.physics.add.group({
        key: 'star',
        repeat: 30,
    });
    
    stars.children.iterate((star) => {
        let size = Phaser.Math.Between(1,2);
        star.setScale(size, size);
        star.setX(Phaser.Math.Between(140,1000));//aslso changed in the update method
        star.setY(Phaser.Math.Between(0,720));
        star.setTint(parseInt('0x' + starColors[Phaser.Math.Between(0,6)]));
        star.setVelocityY(Phaser.Math.Between(100,500));//also changed in the update method
    });

    //side rocks
    sideRocks = this.physics.add.group();
    
    sideRocks.create(0,512,'sideRock').setScale(4).setAngle(180);
    sideRocks.create(0,-512,'sideRock').setScale(4).setAngle(180);
    sideRocks.create(1280,512,'sideRock').setScale(4);
    sideRocks.create(1280,-512,'sideRock').setScale(4);
    
    sideRocks.setTint('0x6d6145');
    
    
    //player
    player = this.physics.add.sprite(600,500,'shipST').setScale(5).setOrigin(0,0);
    player.setSize(16,15);
    player.body.setOffset(0,0);

    //small thrust
    this.anims.create({
        key: 'leftST',
        frames: [{key: 'shipST',frame: 0}],
    });
    this.anims.create({
        key: 'centerST',
        frames: [{key: 'shipST',frame: 1}],
    });
    this.anims.create({
        key: 'rightST',
        frames: [{key: 'shipST',frame: 2}],
    });

    //big thrust
    this.anims.create({
        key: 'leftBT',
        frames: [{key: 'shipBT',frame: 0}],
    });
    this.anims.create({
        key: 'centerBT',
        frames: [{key: 'shipBT',frame: 1}],
    });
    this.anims.create({
        key: 'rightBT',
        frames: [{key: 'shipBT',frame: 2}],
    });

    //no thrust
    this.anims.create({
        key: 'leftNT',
        frames: [{key: 'shipNT',frame: 0}],
    });
    this.anims.create({
        key: 'centerNT',
        frames: [{key: 'shipNT',frame: 1}],
    });
    this.anims.create({
        key: 'rightNT',
        frames: [{key: 'shipNT',frame: 2}],
    });

    //starts centered
    player.anims.play('centerST');

    //player bullets
    playerBullets = this.physics.add.group();//created in runtime

    explosions = this.physics.add.group();

    //dead animation
    this.anims.create({
        key: 'explode',
        frames: this.anims.generateFrameNumbers('explosion', {start: 0, end: 4}),
        frameRate: 5,
        repeat: 0,
    });


    //enemies1 
    enemies1 = this.physics.add.group();

    this.anims.create({
        key: 'move',
        frames: this.anims.generateFrameNumbers('enemies1',{start: 0, end: 4}),
        frameRate: 15,
        repeat: -1
    });


    //colliders
    player.setCollideWorldBounds(true);
    this.physics.add.collider(playerBullets, enemies1, enemy1Hit, null, this);
    this.physics.add.collider(player, enemies1, playerHit, null, this);

    //inputs 
    keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
    keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
    keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
    keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    keyEnter = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);

    //text
    FPS = this.add.text(1220, 16, '0', { fontFamily: 'serious1', fontSize: '32px', fill: '#ffffff' });
    scoreText = this.add.text(20,16,'', { fontFamily: 'serious1', fontSize: '32px', fill: '#ffffff'});
    scoreText.setShadow(4,4,'#1070a7');
    roundText = this.add.text(20,48,'', { fontFamily: 'serious1', fontSize: '32px', fill: '#ffffff'});
    roundText.setShadow(4,4,'#1070a7');
    middleScreenText = this.add.text(640,240,'', { fontFamily: 'serious1', fontSize: '64px', color: '#77cc2a'}).setOrigin(0.5,0);
    middleScreenText.setShadow(4, 4, '#008050')

    //audio
    fire = this.sound.add('fire');
}


function update(){
    if(gameStarted){
        if(!playerDead){
            //movement vertical
            if(keyW.isDown && !keyA.isDown && !keyD.isDown){
                player.anims.play('centerBT', true);
                player.setVelocityY(-500);
            }
            else if(keyS.isDown && !keyA.isDown && !keyD.isDown){
                player.anims.play('centerNT', true);
                player.setVelocityY(500);
            }
            else{
                player.anims.play('centerST', true);
                player.setVelocityY(0);
            }
    
            //movement horizontal
            if(keyA.isDown){
                if(keyW.isDown){
                    player.anims.play('leftBT', true);
                    player.setVelocity(-353,-353);
                }
                else if(keyS.isDown){
                    player.anims.play('leftNT', true);
                    player.setVelocity(-353,353);
                }else{
                    player.anims.play('leftST', true);
                    player.setVelocityX(-500);
                }
            }
            else if(keyD.isDown){
                if(keyW.isDown){
                    player.anims.play('rightBT', true);
                    player.setVelocity(353,-353);
                }
                else if(keyS.isDown){
                    player.anims.play('rightNT', true);
                    player.setVelocity(353,353);
                }else{
                    player.anims.play('rightST', true);
                    player.setVelocityX(500);
                }
            }
            else{
                player.setVelocityX(0);
            }
    
            //shooting
            if(fireTime > 0){
                fireTime--;
            }
            else if(keySpace.isDown && !nextRoundCalled){
                fire.play();
                fireTime = MAXFIRERATE;
                playerBullets.create(player.x+40, player.y, 'pBullet').setVelocityY(-2000).setScale(3);
            } 
            playerBullets.children.each((pB) => {
                //out of screeen
                if(pB.y < 0){
                    pB.destroy();
                    //remove points
                    if(score >= 5){
                        score -=5;
                        scoreText.setText('SCORE: ' + score.toString());
                    }
                }
            });
    
            //enemy movement -->mostly temp
            enemies1.children.each((e1) =>{
                if(e1.y >= 720){
                    e1.y = 0;
                    e1.x = (Phaser.Math.Between(0,1280));
                    const _vel = 600;
                    const _angle = Phaser.Math.FloatBetween(Math.PI/2 + Math.PI/4, Math.PI + Math.PI/4);
                    e1.rotation = _angle;
                    e1.setVelocityX(Math.sin(Math.PI - _angle)*_vel);
                    e1.setVelocityY(Math.cos(Math.PI - _angle)*_vel);
                }
            });

            //explosions
            explosions.children.each((exp) => {
                if(exp.anims.currentFrame.index == 5){
                    exp.destroy();
                } 
            });
    
            //new round check
            if(!nextRoundCalled && (enemies1Spawned == 0 && enemies1Left == 0) /* and the other enemies later on*/){
                countDown = 5;
                middleScreenText.visible = true;
                middleScreenText.setText('NEXT ROUND IN ' + countDown.toString())
                newRound(e1Killed*2,e2Killed*2,e3Killed*2);
                nextRoundCalled = true;
            }

        }else if(playerLives >= 0){//dead transition
            player.anims.play('explode', true);
            if(player.anims.currentFrame.index == 5){
                //restore everything
                //TODO: probably set a timeout for this to happen with a message in the middle of the screen
                playerDead = false;
                enemies1.children.iterate((e1) => {
                    e1.setVelocityY(400);
                });
                player.x = 600;
                player.y = 500;
            }
        
        }else {//Game Over
            player.anims.play('explode', true);
            middleScreenText.setText('GAME OVER');//TODO: change color to red
            //display score and round et al
            middleScreenText.visible = true;
            if(player.anims.currentFrame.index == 5){
                player.visible = false;
            }
        }

    }else if(loaded){
        if(middleScreenText.text == ''){
            middleScreenText.setText('PRESS ENTER TO START!');
            flashInt = setInterval(() => {
                middleScreenText.visible = !middleScreenText.visible;
            }, 500);
        }
        if(keyEnter.isDown && !nextRoundCalled){
            //initial function calls
            gameStart_Spawn();
            clearInterval(flashInt);
            middleScreenText.visible = true;//the flash could ended with it invisible
            middleScreenText.setText(countDown);
            scoreText.setText("SCORE: 0")
            roundText.setText("ROUND: 1")
            nextRoundCalled = true;
        }
    }
    

    //moving sensation
    //change star X and reset Y to make a moving space
    stars.children.iterate((star) => {
        if(star.y > 720 ){
            star.y = -1;
            star.x = Phaser.Math.Between(140,1000);
            star.setVelocityY(Phaser.Math.Between(100,500));
        }
    });

    //moving sides --> resets their y pos back to -512 to maintain a flawless loop 
    sideRocks.children.iterate((sideRock) => {
        sideRock.y += 16;
        if(sideRock.y >= 1232){
            sideRock.y = -512;//should be -816, though i am allowing some overlap just in case
        }
    });

    //update current fps 
    FPS.setText(Phaser.Math.RoundTo(this.game.loop.actualFps,0));

}


//other functions
function gameStart_Spawn(){
    countDownInt = setInterval(() => {    
        countDown--;
        middleScreenText.setText(countDown);
    }, 1000);

    setTimeout(() => {
        spawnEnemy('enemies1',320,0,0,400,3,0);
        spawnEnemy('enemies1',640,0,0,400,3,0);
        spawnEnemy('enemies1',960,0,0,400,3,0);
        enemies1Spawned = 3;
        enemies1Left = 0;
        gameStarted=true;
        nextRoundCalled = false;
        middleScreenText.visible = false;
        clearInterval(countDownInt);
    },3000);
}


function newRound(e1Count, e2Count, e3Count){
    countDownInt = setInterval(() => {
        countDown--;
        middleScreenText.setText('NEXT ROUND IN ' + countDown.toString());
    }, 1000);

    setTimeout(() => {
        round++;
        //enemies1
        enemies1Left = e1Count;
        for(let i = 0; i < maxE1; i++){
            spawnEnemy('enemies1',Phaser.Math.Between(0,1280), 0, 0, 400, 3, 0);
            enemies1Spawned++;
            enemies1Left--;
        }
        nextRoundCalled = false;
        middleScreenText.visible = false;
        clearInterval(countDownInt);
        roundText.setText('ROUND: ' + round.toString());
    }, 5000);
}


function spawnEnemy(key, x, y, velX, velY, scale, rotation){
    enemies1.create(x,y,key).setScale(scale).setVelocity(velX,velY).setRotation(rotation);
}


function enemy1Hit(pB, e1){
    //new explosion --> animation
    var exp = explosions.create(e1.x, e1.y, 'explosion').setScale(3);
    exp.anims.play('explode', true);
    //destroy both entities that collided
    pB.destroy();
    e1.destroy();
    //score and respawn other enemies if left to spawn in curr round 
    score+=100;
    scoreText.setText('SCORE: ' + score.toString());
    enemies1Spawned--;
    e1Killed++;
    if(enemies1Left > 0){
        spawnEnemy('enemies1',Phaser.Math.Between(0,1280), 0, 0, 400, 3, 0);
        enemies1Spawned++;
        enemies1Left--;
    }
}


function playerHit(p,e){
    playerLives--;
    enemies1.children.iterate((e1) =>{
        e1.y = 0;
        e1.setVelocityY(0);
    });
    //set the other ones to not shoot
    player.setVelocity(0,0);
    playerDead = true;
}


//loading the font
async function loadFont(){
    const font = new FontFace('serious1', 'url(https://fonts.cdnfonts.com/s/7418/Serious-1.woff)');
    await font.load();
    document.fonts.add(font);
    document.body.classList.add('fonts-loaded');
    loaded = true;
}

</script>
</body>
</html>